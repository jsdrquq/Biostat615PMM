# Functions to create simulated datasets

#' create_norm_miss_data
#'
#' @param prop_miss Proportion of missing data -> [0, 1]
#' @param alpha y = alpha + beta * x + error, where error ~ N(0, sigma2)
#' @param beta y = alpha + beta * x + error, where error ~ N(0, sigma2)
#' @param sigma2 y = alpha + beta * x + error, where error ~ N(0, sigma2)
#' @param is_mar Missing mechanism -> Missing at random (TRUE) or missing completely at random (FALSE)
#' @param n Number of observations
#'
#' @return dt
#' @export
#'
#' @examples
create_norm_miss_data <- function(prop_miss, alpha = 0, beta = 1, sigma2 = 0.0001, is_mar = TRUE, n = 200) {

  x <- rnorm(n = n)
  error <- rnorm(n = n, sd = sqrt(sigma2))
  y <- alpha + beta * x + error
  dt <- data.frame(x = x, y = y)
  if (is_mar) {   # MAR
    r_ind <- sort(x = x + rnorm(n = n, sd = sqrt(sigma2 / 100)), index.return = TRUE)$ix[1:as.integer(n * prop_miss)]
    dt$y[r_ind] <- NA
  } else {   # MCAR
    r_ind <- rbinom(n = n, size = 1, prob = prop_miss)
    dt$y[r_ind == 0] <- NA
  }

  return(dt)
}

# create_skewed_miss_data <- function(prop_miss, alpha = 0, beta = 1, sigma2 = 0.0001, is_mar = TRUE, n = 200) {
#   # prop_miss: Proportion of missing data -> [0, 1]
#   # alpha, beta, sigma2: y = alpha + beta * x + error, where error ~ N(0, sigma2)
#   # is_mar: Missing mechanism -> Missing at random (TRUE) or missing completely at random (FALSE)
#   # n: Number of observations
#
#   x <- rchisq(n = n)
#   error <- rnorm(n = n, sd = sqrt(sigma2))
#   y <- alpha + beta * x + error
#   dt <- data.frame(x = x, y = y)
#   if (is_mar) {   # MAR
#     r_ind <- sort(x = x + rnorm(n = n, sd = sqrt(sigma2 / 100)), index.return = TRUE)$ix[1:as.integer(n * prop_miss)]
#     dt$y[r_ind] <- NA
#   } else {   # MCAR
#     r_ind <- rbinom(n = n, size = 1, prob = prop_miss)
#     dt$y[r_ind == 0] <- NA
#   }
#
#   return(dt)
# }

# ------

# Simulation

#' single_impute
#'
#' @param data A dataset generated by either create_norm_miss_data() or create_skewed_miss_data()
#' @param mice_method Imputation function to use -> mice.impute.pmm() (TRUE) or self-designed function (FALSE)
#' @param m Number of imputations to implement
#' @param bayeswt Type of regression weights -> "Bayesian" (TRUE) or "Bootstrap" (FALSE)
#' @param donors The size of donor pool (usually between 3 and 10)
#' @param matchtype Type of matching distance -> {0, 1, 2}
#' @param ridge Ridge penalty (a small number close to 0)
#'
#' @return results
#' @export
#'
#' @examples
single_impute <- function(data, mice_method = FALSE, m = 20,
                          bayeswt = TRUE, donors = 5, matchtype = 1, ridge = 1e-05) {

  est <- rep(x = NA, times = m)
  u <- rep(x = NA, times = m)

  for (i in 1:m) {
    data_imp <- data
    if (mice_method) {
      y_imp <- mice.impute.pmm(y = data_imp$y, ry = !is.na(data_imp$y), x = data_imp$x,
                               donors = donors, matchtype = matchtype)
    } else {
      y_imp <- pmm_impute(y = data_imp$y, ry = !is.na(data_imp$y), x = data_imp$x,
                          bayeswt = bayeswt, donors = donors, matchtype = matchtype)
    }

    data_imp$y[is.na(data$y)] <- y_imp
    lm_summary <- summary(lm(formula = y ~ x, data = data_imp))$coefficients
    est[i] <- lm_summary["x", "Estimate"]
    u[i] <- lm_summary["x", "Std. Error"]
  }

  Q_bar <- mean(est)
  U_bar <- mean(u^2)
  B <- var(est)
  T_val <- U_bar + (1 + 1 / m) * B
  lambda <- (B + B / m) / T_val
  r <- (B + B / m) / U_bar
  nu_old <- (m - 1) / lambda^2
  nu_com <- nrow(data) - 2
  nu_obs <- (nu_com + 1) / (nu_com + 3) * nu_com * (1 - lambda)
  nu <- (nu_old * nu_obs) / (nu_old + nu_obs)
  Q_025 <- Q_bar - qt(p = 0.975, df = nu) * sqrt(T_val)
  Q_975 <- Q_bar + qt(p = 0.975, df = nu) * sqrt(T_val)

  results <- c(Q_bar, Q_025, Q_975)
  names(results) <- c("Mean", "2.5%", "97.5%")

  return(results)
}

#' simulation
#'
#' @param data
#' @param simu_times Number of simulations to run
#' @param mice_method
#' @param m
#' @param bayeswt
#' @param donors
#' @param matchtype
#' @param ridge
#'
#' @return q_simu
#' @export
#'
#' @examples
simulation <- function(data, simu_times = 500, mice_method = FALSE, m = 20,
                       bayeswt = TRUE, donors = 5, matchtype = 1, ridge = 1e-05) {

  q_simu <- data.frame()

  for (t in 1:simu_times) {
    single_results <- single_impute(data = data, mice_method = mice_method, m = m,
                                    bayeswt = bayeswt, donors = donors, matchtype = matchtype)
    q_simu <- rbind(q_simu, single_results)
  }

  colnames(q_simu) <- c("Mean", "2.5%", "97.5%")

  return(q_simu)
}

# ------

# Assessment of estimated regression coefficients

#' eval_pmm
#'
#' @param simu_results Results of simulation generated by simulation()
#' @param true_coef The true value of coefficient to evaluate
#'
#' @return eval_metrics
#' @export
#'
#' @examples
eval_pmm <- function(simu_results, true_coef) {

  Bias <- mean(simu_results[, "Mean"]) - true_coef   # bias
  RMSE <- sqrt(mean((simu_results[, "Mean"] - true_coef)^2))   # rooted mean square error

  eval_metrics <- c(Bias, RMSE)
  names(eval_metrics) <- c("Bias", "RMSE")

  return(eval_metrics)
}

#' get_eval_results
#'
#' @param data
#' @param true_coef The true value of coefficient to evaluate
#' @param donors The size of donor pool (usually between 3 and 10)
#' @param matchtype Type of matching distance -> {0, 1, 2}
#' @param simu_times
#'
#' @return results
#' @export
#'
#' @examples
get_eval_results <- function(data, true_coef, donors, matchtype, simu_times = 500) {
  # Simulation
  simu_bayes <- simulation(data = data, simu_times = simu_times, donors = donors, matchtype = matchtype)
  simu_boot <- simulation(data = data, simu_times = simu_times, bayeswt = FALSE, donors = donors, matchtype = matchtype)
  simu_mice <- simulation(data = data, simu_times = simu_times, mice_method = TRUE, donors = donors, matchtype = matchtype)
  # Imputed results assessment
  eval_bayes <- eval_pmm(simu_results = simu_bayes, true_coef = true_coef)
  eval_boot <- eval_pmm(simu_results = simu_boot, true_coef = true_coef)
  eval_mice <- eval_pmm(simu_results = simu_mice, true_coef = true_coef)
  # Summarize assessments
  results <- rbind.data.frame(eval_bayes, eval_boot, eval_mice)
  colnames(results) <- c("Bias", "RMSE")
  results <- results %>%
    mutate(func = c("Bayesian", "Bootstrap", "Bayesian (MICE)")) %>%
    relocate(func, .before = everything())
  rownames(results) <- NULL

  return(results)
}


